<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEED Swap - Woofswap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
            --error-color: #ff4444;
            --success-color: #00C851;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #e68a00; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ff9100;
        }
        select, input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: #4a4f7a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
            transition: background 0.2s;
        }
        .percentage-buttons button:hover { background: #5a5f8a; }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:disabled {
            background: #4a4f7a;
            cursor: not-allowed;
        }
        .swap-button:hover:not(:disabled) { background: #e68a00; }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            text-align: center;
        }
        .status.error { color: var(--error-color); }
        .status.success { color: var(--success-color); }
        .swap-note {
            font-size: 0.9em;
            color: #ff9100;
            margin-top: 5px;
            text-align: left;
            word-wrap: break-word;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .percentage-buttons button { padding: 5px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">FEED Swap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>Buy FEED with</span>
                <span id="buyBalance">Balance: 0</span>
            </div>
            <select id="payToken">
                <option value="BONE">BONE</option>
                <option value="WOOF">WOOF</option>
                <option value="LUISA">LUISA</option>
            </select>
            <input type="number" id="payAmount" placeholder="0.0" step="0.01" min="0">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="buyNote"></div>
        </div>
        <button class="swap-button" id="approveBuyButton" onclick="approveBuyToken()" style="display: none;">Approve Token</button>
        <button class="swap-button" id="buyButton" onclick="buyFEED()" disabled>Buy FEED</button>
        <div class="swap-box">
            <div class="balance-row">
                <span>Sell FEED for BONE</span>
                <span id="sellBalance">Balance: 0</span>
            </div>
            <input type="number" id="sellAmount" placeholder="0.0" step="0.01" min="0">
            <div class="percentage-buttons">
                <button onclick="setSellPercentage(25)">25%</button>
                <button onclick="setSellPercentage(50)">50%</button>
                <button onclick="setSellPercentage(75)">75%</button>
                <button onclick="setSellPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="sellNote"></div>
        </div>
        <button class="swap-button" id="approveButton" onclick="approveFEED()" disabled>Approve FEED</button>
        <button class="swap-button" id="sellButton" onclick="sellFEED()" style="display: none;" disabled>Sell FEED</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const tokens = {
            BONE: { address: "", symbol: "BONE", isNative: true, decimals: 18 },
            WBONE: { address: "0x839FdB6cc98342B428E074C1573ADF6D48CA3bFd", symbol: "WBONE", decimals: 18 },
            WOOF: { address: "0xD0daa7B6ff1B40d3cc6F0B2Cf7E85cB993D1c834", symbol: "WOOF", decimals: 18 },
            LUISA: { address: "0x0cCD687CC6F8461170336D8e8cf46A39313DEab9", symbol: "LUISA", decimals: 18 },
            FEED: { address: "0xe9Cb2D7ADC24Fc59FE00D6C0A0669BDF16805Fe0", symbol: "FEED", decimals: 18 }
        };

        const poolAddresses = {
            WBONE_FEED: "0xD4301bA08076C14Dfc93fd0a94151E338874D7FE",
            WBONE_WOOF: "0xE7481D3BB7ae1f11E17D64244102044922Cf565F",
            WBONE_LUISA: "0x95e48cee32dBcEF91Fb99Db4c1Af3Ba7Ef798CB5",
            WOOF_FEED: "0xa636D7874FFD251da8901Ba8751B23f354544BcC",
            LUISA_FEED: "0x0A1728A1db63Ed5fdEBBcEbB686AdDfe3127deD0"
        };

        const routerAddress = "0x96b16aBD53Bfd765F4CD118590C1d0be8B57DE24";
        const feedSwapAddress = "0xc1EB1d6AA8d5bC41507Bbc6F29ECC6B12D9Aa2F6";

        const routerAbi = [
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];

        const feedSwapAbi = [
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedSwap.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedSwap.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithWOOF","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedSwap.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithLUISA","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedSwap.SwapRoute[]","name":"routes","type":"tuple[]"}],"name":"getExpectedAmountsOut","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedSwap.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"sellToBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[],"name":"getAllPoolReserves","outputs":[{"components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"token0","type":"address"},{"internalType":"address","name":"token1","type":"address"},{"internalType":"uint256","name":"reserve0","type":"uint256"},{"internalType":"uint256","name":"reserve1","type":"uint256"}],"internalType":"struct FeedSwap.PoolReserves[]","name":"reserves","type":"tuple[]"}],"stateMutability":"view","type":"function"}
        ];

        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"}
        ];

        const shibarium = {
            chainId: 109,
            chainName: 'Shibarium',
            nativeCurrency: { name: 'BONE', symbol: 'BONE', decimals: 18 },
            rpcUrls: ['https://rpc.shibrpc.com'],
            blockExplorerUrls: ['https://shibariumscan.io']
        };

        let web3, account, router, feedSwap;
        let payBalance = '0';
        let feedBalance = '0';
        let reserves = {};
        const SLIPPAGE_TOLERANCE = 0.005; // 0.5%

        const connectWalletButton = document.getElementById('connectWalletButton');
        const networkStatus = document.getElementById('networkStatus');
        const buyBalance = document.getElementById('buyBalance');
        const sellBalance = document.getElementById('sellBalance');
        const payTokenSelect = document.getElementById('payToken');
        const payAmountInput = document.getElementById('payAmount');
        const sellAmountInput = document.getElementById('sellAmount');
        const buyNote = document.getElementById('buyNote');
        const sellNote = document.getElementById('sellNote');
        const approveBuyButton = document.getElementById('approveBuyButton');
        const buyButton = document.getElementById('buyButton');
        const approveButton = document.getElementById('approveButton');
        const sellButton = document.getElementById('sellButton');

        document.addEventListener('DOMContentLoaded', () => {
            connectWalletButton.addEventListener('click', connectWallet);
            payTokenSelect.addEventListener('change', updateBalances);
            payAmountInput.addEventListener('input', debounce(async () => {
                await fetchReserves();
                checkBuyRoutes();
            }, 500));
            sellAmountInput.addEventListener('input', debounce(async () => {
                await fetchReserves();
                checkSellRoutes();
            }, 500));
            setupWalletListeners();
        });

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        async function connectWallet() {
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask.");
                connectWalletButton.disabled = true;
                setStatus("Connecting... <span class='spinner'></span>");
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                await switchToShibarium();
                router = new web3.eth.Contract(routerAbi, routerAddress);
                feedSwap = new web3.eth.Contract(feedSwapAbi, feedSwapAddress);
                connectWalletButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                setStatus("Connected to Shibarium", true);
                await fetchReserves();
                await updateBalances();
            } catch (error) {
                setStatus(`Failed: ${error.message}`, false);
                resetUI();
            } finally {
                connectWalletButton.disabled = false;
            }
        }

        async function switchToShibarium() {
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 109) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: "0x6d" }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [shibarium]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
        }

        function resetUI() {
            connectWalletButton.textContent = "Connect Wallet";
            setStatus("Click to connect...");
            buyBalance.textContent = "Balance: 0";
            sellBalance.textContent = "Balance: 0";
            buyNote.innerHTML = "";
            sellNote.innerHTML = "";
            buyButton.disabled = true;
            approveButton.disabled = true;
            approveBuyButton.style.display = 'none';
            buyButton.style.display = 'block';
            approveButton.style.display = 'block';
            sellButton.style.display = 'none';
            payAmountInput.value = '';
            sellAmountInput.value = '';
        }

        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await switchToShibarium();
                        router = new web3.eth.Contract(routerAbi, routerAddress);
                        feedSwap = new web3.eth.Contract(feedSwapAbi, feedSwapAddress);
                        connectWalletButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                        setStatus("Connected to Shibarium", true);
                        await fetchReserves();
                        await updateBalances();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    feedSwap = null;
                    resetUI();
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 109) {
                    web3 = null;
                    account = null;
                    router = null;
                    feedSwap = null;
                    resetUI();
                    setStatus("Wrong network. Reconnect to Shibarium.", false);
                } else if (account) {
                    await connectWallet();
                }
            });
        }

        async function fetchReserves() {
            if (!web3 || !feedSwap) return;
            try {
                const poolReserves = await feedSwap.methods.getAllPoolReserves().call();
                reserves = {};
                poolReserves.forEach(pool => {
                    const key = `${pool.token0}-${pool.token1}`;
                    const reverseKey = `${pool.token1}-${pool.token0}`;
                    reserves[key] = {
                        reserve0: web3.utils.toBN(pool.reserve0),
                        reserve1: web3.utils.toBN(pool.reserve1),
                        token0: pool.token0,
                        token1: pool.token1
                    };
                    reserves[reverseKey] = {
                        reserve0: web3.utils.toBN(pool.reserve1),
                        reserve1: web3.utils.toBN(pool.reserve0),
                        token0: pool.token1,
                        token1: pool.token0
                    };
                });
            } catch (error) {
                setStatus("Error fetching pool reserves.", false);
            }
        }

        async function updateBalances() {
            if (!web3 || !account) return;
            const payTokenSymbol = payTokenSelect.value;
            const payToken = tokens[payTokenSymbol];
            try {
                if (payToken.isNative) {
                    payBalance = await web3.eth.getBalance(account);
                    buyBalance.textContent = `Balance: ${parseFloat(web3.utils.fromWei(payBalance, 'ether')).toFixed(4)}`;
                } else {
                    const tokenContract = new web3.eth.Contract(erc20Abi, payToken.address);
                    payBalance = await tokenContract.methods.balanceOf(account).call();
                    buyBalance.textContent = `Balance: ${parseFloat(web3.utils.fromWei(payBalance, 'ether')).toFixed(4)}`;
                }
                const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
                feedBalance = await feedContract.methods.balanceOf(account).call();
                sellBalance.textContent = `Balance: ${parseFloat(web3.utils.fromWei(feedBalance, 'ether')).toFixed(4)}`;
            } catch (error) {
                setStatus("Error fetching balances.", false);
            }
        }

        function setPercentage(percentage) {
            if (!payBalance || !web3) {
                setStatus("Please connect wallet first.", false);
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = parseFloat(web3.utils.fromWei(payBalance, 'ether'));
                if (payTokenSelect.value === 'BONE') {
                    amount = Math.max(0, amount - 0.001);
                }
            } else {
                amount = parseFloat(web3.utils.fromWei(payBalance, 'ether')) * (percentage / 100);
            }
            payAmountInput.value = amount.toFixed(4);
            fetchReserves().then(checkBuyRoutes);
        }

        function setSellPercentage(percentage) {
            if (!feedBalance || !web3) {
                setStatus("Please connect wallet first.", false);
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = parseFloat(web3.utils.fromWei(feedBalance, 'ether'));
            } else {
                amount = parseFloat(web3.utils.fromWei(feedBalance, 'ether')) * (percentage / 100);
            }
            sellAmountInput.value = amount.toFixed(4);
            fetchReserves().then(checkSellRoutes);
        }

        function getReserves(tokenA, tokenB) {
            const key = `${tokenA}-${tokenB}`;
            if (reserves[key]) {
                return {
                    reserveA: reserves[key].reserve0,
                    reserveB: reserves[key].reserve1,
                    exists: true
                };
            }
            return { reserveA: web3.utils.toBN('0'), reserveB: web3.utils.toBN('0'), exists: false };
        }

        function getAmountOut(amountIn, reserveIn, reserveOut) {
            if (amountIn.lte(web3.utils.toBN('0')) || reserveIn.lte(web3.utils.toBN('0')) || reserveOut.lte(web3.utils.toBN('0'))) {
                return web3.utils.toBN('0');
            }
            const amountInWithFee = amountIn.mul(web3.utils.toBN(997));
            const numerator = amountInWithFee.mul(reserveOut);
            const denominator = reserveIn.mul(web3.utils.toBN(1000)).add(amountInWithFee);
            return numerator.div(denominator);
        }

        function getOutputForRoute(route, amountIn) {
            let currentAmount = web3.utils.toBN(amountIn);
            for (let i = 0; i < route.length; i++) {
                const { reserveA, reserveB, exists } = getReserves(route[i].from, route[i].to);
                if (!exists) return web3.utils.toBN('0');
                currentAmount = getAmountOut(currentAmount, reserveA, reserveB);
            }
            return currentAmount;
        }

        function calculatePriceImpact(route, amountIn) {
            let currentAmount = web3.utils.toBN(amountIn);
            let totalReserveIn = web3.utils.toBN('0');
            let totalReserveOut = web3.utils.toBN('0');
            for (let i = 0; i < route.length; i++) {
                const { reserveA, reserveB, exists } = getReserves(route[i].from, route[i].to);
                if (!exists) return 0;
                const reserveIn = reserveA;
                const reserveOut = reserveB;
                totalReserveIn = totalReserveIn.add(reserveIn);
                totalReserveOut = totalReserveOut.add(reserveOut);
                currentAmount = getAmountOut(currentAmount, reserveIn, reserveOut);
            }
            if (totalReserveOut.eq(web3.utils.toBN('0'))) return 0;
            const priceImpact = currentAmount.mul(web3.utils.toBN('10000')).div(totalReserveOut).toNumber() / 100;
            return priceImpact;
        }

        function optimizeRoutes(possibleRoutes, totalAmountInWei) {
            const totalAmountIn = web3.utils.toBN(totalAmountInWei);
            if (totalAmountIn.lte(web3.utils.toBN('0'))) return [];

            const routeData = possibleRoutes.map(route => {
                const smallAmount = web3.utils.toBN(web3.utils.toWei('0.01', 'ether'));
                const output = getOutputForRoute(route, smallAmount);
                const price = output.gt(web3.utils.toBN('0')) ? smallAmount.mul(web3.utils.toBN(1e18)).div(output) : web3.utils.toBN(1e36);
                return { route, price, output };
            });

            routeData.sort((a, b) => a.price.cmp(b.price));

            const swapRoutes = [];
            let remainingAmount = totalAmountIn;
            const STEP_AMOUNT = web3.utils.toBN(web3.utils.toWei('0.1', 'ether'));

            while (remainingAmount.gt(web3.utils.toBN('0'))) {
                let bestRoute = null;
                let bestOutput = web3.utils.toBN('0');
                let bestAmountIn = web3.utils.toBN('0');

                for (const { route } of routeData) {
                    const amountToTest = remainingAmount.lt(STEP_AMOUNT) ? remainingAmount : STEP_AMOUNT;
                    const output = getOutputForRoute(route, amountToTest);
                    if (output.gt(bestOutput)) {
                        bestOutput = output;
                        bestRoute = route;
                        bestAmountIn = amountToTest;
                    }
                }

                if (!bestRoute || bestOutput.lte(web3.utils.toBN('0'))) break;

                const existingRoute = swapRoutes.find(r => r.path === bestRoute);
                if (existingRoute) {
                    existingRoute.amountIn = web3.utils.toBN(existingRoute.amountIn).add(bestAmountIn).toString();
                    existingRoute.amountOut = existingRoute.amountOut.add(bestOutput);
                } else {
                    swapRoutes.push({
                        amountIn: bestAmountIn.toString(),
                        amountOutMin: '0',
                        path: bestRoute,
                        amountOut: bestOutput
                    });
                }

                remainingAmount = remainingAmount.sub(bestAmountIn);
            }

            if (remainingAmount.gt(web3.utils.toBN('0'))) {
                const bestRoute = routeData[0]?.route;
                if (bestRoute) {
                    const output = getOutputForRoute(bestRoute, remainingAmount);
                    const existingRoute = swapRoutes.find(r => r.path === bestRoute);
                    if (existingRoute) {
                        existingRoute.amountIn = web3.utils.toBN(existingRoute.amountIn).add(remainingAmount).toString();
                        existingRoute.amountOut = existingRoute.amountOut.add(output);
                    } else {
                        swapRoutes.push({
                            amountIn: remainingAmount.toString(),
                            amountOutMin: '0',
                            path: bestRoute,
                            amountOut: output
                        });
                    }
                }
            }

            return swapRoutes;
        }

        async function checkAllowance(tokenAddress, amount) {
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, feedSwapAddress).call();
            return web3.utils.toBN(allowance).gte(web3.utils.toBN(amount));
        }

        async function checkBuyRoutes() {
            buyNote.innerHTML = '';
            buyButton.disabled = true;
            approveBuyButton.style.display = 'none';
            buyButton.style.display = 'block';

            const payTokenSymbol = payTokenSelect.value;
            const payToken = tokens[payTokenSymbol];
            const amountIn = payAmountInput.value;

            if (!web3 || !account || !amountIn || amountIn <= 0) {
                buyNote.innerHTML = 'Please enter a valid amount.';
                return;
            }

            let amountInWei;
            try {
                amountInWei = web3.utils.toWei(amountIn.toString(), 'ether');
                amountInWei = web3.utils.toBN(amountInWei);
            } catch (error) {
                buyNote.innerHTML = 'Invalid amount entered.';
                return;
            }

            if (amountInWei.gt(web3.utils.toBN(payBalance))) {
                buyNote.innerHTML = 'Insufficient balance.';
                return;
            }

            buyNote.innerHTML = `Checking routes... <span class="spinner"></span>`;

            let needsApproval = false;
            if (!payToken.isNative) {
                const hasAllowance = await checkAllowance(payToken.address, amountInWei);
                needsApproval = !hasAllowance;
            }

            let possibleRoutes = [];
            if (payTokenSymbol === 'BONE') {
                possibleRoutes = [
                    [{ from: tokens.WBONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.WBONE.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.WBONE.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'WOOF') {
                possibleRoutes = [
                    [{ from: tokens.WOOF.address, to: tokens.WBONE.address, stable: false }, { from: tokens.WBONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'LUISA') {
                possibleRoutes = [
                    [{ from: tokens.LUISA.address, to: tokens.WBONE.address, stable: false }, { from: tokens.WBONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            }

            try {
                const swapRoutes = optimizeRoutes(possibleRoutes, amountInWei);

                if (!swapRoutes.length) {
                    buyNote.innerHTML = 'No available routes found.';
                    return;
                }

                let totalOutput = web3.utils.toBN('0');
                let totalInput = web3.utils.toBN('0');
                let totalPriceImpact = 0;
                let html = 'AVAILABLE ROUTES:<br>';
                for (const route of swapRoutes) {
                    const amountInEther = parseFloat(web3.utils.fromWei(route.amountIn, 'ether'));
                    const outputEther = parseFloat(web3.utils.fromWei(route.amountOut.toString(), 'ether'));
                    totalOutput = totalOutput.add(route.amountOut);
                    totalInput = totalInput.add(web3.utils.toBN(route.amountIn));
                    const priceImpact = calculatePriceImpact(route.path, route.amountIn);
                    totalPriceImpact += priceImpact * (amountInEther / parseFloat(amountIn));
                    const path = route.path.map(p => Object.keys(tokens).find(k => tokens[k].address === p.from) || p.from).join(' -> ') + ' -> FEED';
                    const share = amountInEther / parseFloat(amountIn) * 100;
                    html += `${path}: ${outputEther.toFixed(2)} FEED (${share.toFixed(1)}%) -> ${amountInEther.toFixed(2)} ${payTokenSymbol}<br>`;
                }

                const expectedAmounts = await feedSwap.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    const expectedAmount = web3.utils.toBN(expectedAmounts[i]);
                    const minAmount = expectedAmount.mul(web3.utils.toBN((1 - SLIPPAGE_TOLERANCE) * 1000)).div(web3.utils.toBN(1000));
                    swapRoutes[i].amountOutMin = minAmount.toString();
                }

                const totalOutputEther = parseFloat(web3.utils.fromWei(totalOutput.toString(), 'ether'));
                const totalInputEther = parseFloat(web3.utils.fromWei(totalInput.toString(), 'ether'));
                const pricePerFeed = totalInputEther / totalOutputEther;
                const minReceived = totalOutputEther * (1 - SLIPPAGE_TOLERANCE);
                html += `TOTAL: ${totalOutputEther.toFixed(2)} FEED<br>`;
                html += `Price: ${pricePerFeed.toFixed(4)} ${payTokenSymbol} per FEED<br>`;
                html += `Minimum received: ${minReceived.toFixed(2)} FEED<br>`;
                html += `Price impact: ${totalPriceImpact.toFixed(3)}%`;
                buyNote.innerHTML = html;
                window.buyRoutes = swapRoutes;
                window.buyTotalAmount = amountInWei.toString();
                window.buyPayToken = payTokenSymbol;
                buyButton.disabled = false;
                approveBuyButton.style.display = needsApproval ? 'block' : 'none';
                buyButton.style.display = needsApproval ? 'none' : 'block';
            } catch (error) {
                buyNote.innerHTML = 'Error checking routes: ' + (error.message || "Unknown error");
            }
        }

        async function approveBuyToken() {
            const payTokenSymbol = window.buyPayToken;
            const totalAmount = window.buyTotalAmount;
            if (!web3 || !account || !totalAmount) {
                setStatus("Please connect wallet and enter a valid amount.", false);
                return;
            }
            try {
                approveBuyButton.disabled = true;
                setStatus(`Approving ${payTokenSymbol}... <span class="spinner"></span>`);
                const tokenContract = new web3.eth.Contract(erc20Abi, tokens[payTokenSymbol].address);
                await tokenContract.methods.approve(feedSwapAddress, totalAmount).send({ from: account });
                setStatus("Approval successful!", true);
                approveBuyButton.style.display = 'none';
                buyButton.style.display = 'block';
                buyButton.disabled = false;
            } catch (error) {
                setStatus(error.message || "Approval failed.", false);
            } finally {
                approveBuyButton.disabled = false;
            }
        }

        async function buyFEED() {
            if (!web3 || !account || !window.buyRoutes) {
                setStatus("Please connect wallet and enter a valid amount.", false);
                return;
            }
            const payTokenSymbol = window.buyPayToken;
            const totalAmount = window.buyTotalAmount;
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            try {
                buyButton.disabled = true;
                setStatus("Processing buy... <span class='spinner'></span>");
                if (payTokenSymbol === 'BONE') {
                    await feedSwap.methods.buyWithBONE(window.buyRoutes, deadline).send({ from: account, value: totalAmount });
                } else if (payTokenSymbol === 'WOOF') {
                    await feedSwap.methods.buyWithWOOF(window.buyRoutes, totalAmount, deadline).send({ from: account });
                } else if (payTokenSymbol === 'LUISA') {
                    await feedSwap.methods.buyWithLUISA(window.buyRoutes, totalAmount, deadline).send({ from: account });
                }
                setStatus("Buy successful!", true);
                payAmountInput.value = '';
                buyNote.innerHTML = '';
                await fetchReserves();
                await updateBalances();
            } catch (error) {
                setStatus(error.message || "Buy failed.", false);
            } finally {
                buyButton.disabled = false;
            }
        }

        async function checkSellRoutes() {
            sellNote.innerHTML = '';
            approveButton.style.display = 'block';
            sellButton.style.display = 'none';
            approveButton.disabled = true;
            sellButton.disabled = true;

            const amountIn = sellAmountInput.value;
            if (!web3 || !account || !amountIn || amountIn <= 0) {
                sellNote.innerHTML = 'Please enter a valid amount.';
                return;
            }

            let amountInWei;
            try {
                amountInWei = web3.utils.toWei(amountIn.toString(), 'ether');
                amountInWei = web3.utils.toBN(amountInWei);
            } catch (error) {
                sellNote.innerHTML = 'Invalid amount entered.';
                return;
            }

            if (amountInWei.gt(web3.utils.toBN(feedBalance))) {
                sellNote.innerHTML = 'Insufficient balance.';
                return;
            }

            sellNote.innerHTML = `Checking routes... <span class="spinner"></span>`;

            const hasAllowance = await checkAllowance(tokens.FEED.address, amountInWei);
            const needsApproval = !hasAllowance;

            const possibleRoutes = [
                [{ from: tokens.FEED.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.WBONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.WBONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.WBONE.address, stable: false }]
            ];

            try {
                const swapRoutes = optimizeRoutes(possibleRoutes, amountInWei);

                if (!swapRoutes.length) {
                    sellNote.innerHTML = 'No available routes found.';
                    return;
                }

                let totalOutput = web3.utils.toBN('0');
                let totalInput = web3.utils.toBN('0');
                let totalPriceImpact = 0;
                let html = 'AVAILABLE ROUTES:<br>';
                for (const route of swapRoutes) {
                    const amountInEther = parseFloat(web3.utils.fromWei(route.amountIn, 'ether'));
                    const outputEther = parseFloat(web3.utils.fromWei(route.amountOut.toString(), 'ether'));
                    totalOutput = totalOutput.add(route.amountOut);
                    totalInput = totalInput.add(web3.utils.toBN(route.amountIn));
                    const priceImpact = calculatePriceImpact(route.path, route.amountIn);
                    totalPriceImpact += priceImpact * (amountInEther / parseFloat(amountIn));
                    const path = ['FEED'].concat(route.path.map(p => Object.keys(tokens).find(k => tokens[k].address === p.to) || p.to)).join(' -> ');
                    const share = amountInEther / parseFloat(amountIn) * 100;
                    html += `${path}: ${outputEther.toFixed(2)} BONE (${share.toFixed(1)}%) -> ${amountInEther.toFixed(2)} FEED<br>`;
                }

                const expectedAmounts = await feedSwap.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    const expectedAmount = web3.utils.toBN(expectedAmounts[i]);
                    const minAmount = expectedAmount.mul(web3.utils.toBN((1 - SLIPPAGE_TOLERANCE) * 1000)).div(web3.utils.toBN(1000));
                    swapRoutes[i].amountOutMin = minAmount.toString();
                }

                const totalOutputEther = parseFloat(web3.utils.fromWei(totalOutput.toString(), 'ether'));
                const totalInputEther = parseFloat(web3.utils.fromWei(totalInput.toString(), 'ether'));
                const pricePerFeed = totalOutputEther / totalInputEther;
                const minReceived = totalOutputEther * (1 - SLIPPAGE_TOLERANCE);
                html += `TOTAL: ${totalOutputEther.toFixed(2)} BONE<br>`;
                html += `Price: ${pricePerFeed.toFixed(4)} BONE per FEED<br>`;
                html += `Minimum received: ${minReceived.toFixed(2)} BONE<br>`;
                html += `Price impact: ${totalPriceImpact.toFixed(3)}%`;
                sellNote.innerHTML = html;
                window.sellRoutes = swapRoutes;
                window.sellTotalAmount = amountInWei.toString();
                approveButton.style.display = needsApproval ? 'block' : 'none';
                sellButton.style.display = needsApproval ? 'none' : 'block';
                approveButton.disabled = false;
                if (!needsApproval) sellButton.disabled = false;
            } catch (error) {
                sellNote.innerHTML = 'Error checking routes: ' + (error.message || "Unknown error");
            }
        }

        async function approveFEED() {
            if (!web3 || !account || !window.sellTotalAmount) {
                setStatus("Please connect wallet and enter a valid amount.", false);
                return;
            }
            try {
                approveButton.disabled = true;
                setStatus("Approving FEED... <span class='spinner'></span>");
                const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
                await feedContract.methods.approve(feedSwapAddress, window.sellTotalAmount).send({ from: account });
                setStatus("Approval successful!", true);
                approveButton.style.display = 'none';
                sellButton.style.display = 'block';
                sellButton.disabled = false;
            } catch (error) {
                setStatus(error.message || "Approval failed.", false);
            } finally {
                approveButton.disabled = false;
            }
        }

        async function sellFEED() {
            if (!web3 || !account || !window.sellRoutes) {
                setStatus("Please connect wallet and enter a valid amount.", false);
                return;
            }
            const totalAmount = window.sellTotalAmount;
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            try {
                sellButton.disabled = true;
                setStatus("Processing sell... <span class='spinner'></span>");
                await feedSwap.methods.sellToBONE(window.sellRoutes, totalAmount, deadline).send({ from: account });
                setStatus("Sell successful!", true);
                sellAmountInput.value = '';
                sellNote.innerHTML = '';
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                await fetchReserves();
                await updateBalances();
            } catch (error) {
                setStatus(error.message || "Sell failed.", false);
            } finally {
                sellButton.disabled = false;
            }
        }

        function setStatus(message, success = null) {
            networkStatus.innerHTML = message;
            networkStatus.className = 'status';
            if (success === true) {
                networkStatus.classList.add('success');
            } else if (success === false) {
                networkStatus.classList.add('error');
            }
        }
    </script>
</body>
</html>
