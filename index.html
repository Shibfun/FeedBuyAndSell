<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEED Swap - Woofswap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #e68a00; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ff9100;
        }
        .token-select {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .token-select div {
            display: flex;
            align-items: center;
        }
        .token-select img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        .token-select .placeholder {
            width: 24px;
            height: 24px;
            background: #4a4f7a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        select, input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: #4a4f7a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
        }
        .percentage-buttons button:hover { background: #5a5f8a; }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:disabled {
            background: #4a4f7a;
            cursor: not-allowed;
        }
        .swap-button:hover:not(:disabled) { background: #e68a00; }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .swap-note {
            font-size: 0.9em;
            color: #ff9100;
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .dog-section {
            text-align: center;
            margin-top: 20px;
        }
        .dog-section img {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
        }
        .dog-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .percentage-buttons button { padding: 5px; }
            .dog-section img { width: 50px; height: 50px; }
            .dog-message { font-size: 0.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">FEED Swap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>Buy FEED with</span>
                <span id="buyBalance">Balance: 0</span>
            </div>
            <select id="payToken">
                <option value="BONE">BONE</option>
                <option value="0xD0daa7B6ff1B40d3cc6F0B2Cf7E85cB993D1c834">WOOF</option>
                <option value="0x0cCD687CC6F8461170336D8e8cf46A39313DEab9">LUISA</option>
            </select>
            <input type="number" id="payAmount" placeholder="0.0" step="0.01">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="buyNote"></div>
        </div>
        <button class="swap-button" id="buyButton" onclick="buyFEED()">Buy FEED</button>
        <div class="swap-box">
            <div class="balance-row">
                <span>Sell FEED for BONE</span>
                <span id="sellBalance">Balance: 0</span>
            </div>
            <input type="number" id="sellAmount" placeholder="0.0" step="0.01">
            <div class="percentage-buttons">
                <button onclick="setSellPercentage(25)">25%</button>
                <button onclick="setSellPercentage(50)">50%</button>
                <button onclick="setSellPercentage(75)">75%</button>
                <button onclick="setSellPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="sellNote"></div>
        </div>
        <button class="swap-button" id="sellButton" onclick="sellFEED()">Sell FEED</button>
        <div class="dog-section">
            <img src="images/shiba.gif" alt="Shiba Dog">
            <div class="dog-message" id="dogMessage">"Woof! Connect your wallet to start swapping, pup!"</div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const tokens = {
            BONE: { address: "0x839FdB6cc98342B428E074C1573ADF6D48CA3bFd", symbol: "BONE", logo: "images/bone.png", isNative: true },
            WOOF: { address: "0xD0daa7B6ff1B40d3cc6F0B2Cf7E85cB993D1c834", symbol: "WOOF", logo: "images/woof.png" },
            LUISA: { address: "0x0cCD687CC6F8461170336D8e8cf46A39313DEab9", symbol: "LUISA", logo: "images/luisa.png" },
            FEED: { address: "0xe9Cb2D7ADC24Fc59FE00D6C0A0669BDF16805Fe0", symbol: "FEED", logo: "images/feed.png" }
        };
        const routerAddress = "0x96b16aBD53Bfd765F4CD118590C1d0be8B57DE24";
        const factoryAddress = "0xB9fbdFA27B7ba8BB2d4bB4aB399e4c55F0F7F83a";
        const feedBuyAndSellAddress = "0x852f466F286F3fa32B6f3ca1D65080D1070Dabf4";
        const routerAbi = [
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];
        const factoryAbi = [
            {"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];
        const feedBuyAndSellAbi = [
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithLUISA","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithWOOF","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"}],"name":"getExpectedAmountsOut","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"sellToBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"}
        ];
        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"}
        ];
        const shibarium = {
            chainId: 109,
            chainName: 'Shibarium',
            nativeCurrency: { name: 'BONE', symbol: 'BONE', decimals: 18 },
            rpcUrls: ['https://rpc.shibrpc.com'],
            blockExplorerUrls: ['https://shibariumscan.io']
        };
        let web3, account, router, factory, feedBuyAndSell;
        let payBalance = '0';
        let feedBalance = '0';
        const defaultSlippage = 0.005;

        const dogMessages = {
            connectStart: ["Woof woof! Sniffing out your wallet, hold tight, human!","Arf! Digging into Shibarium, let’s fetch that wallet!","Bow wow! Connecting to your stash, stay pawsitive!","Woof! I smell a wallet, let’s link it up quick!"],
            connectSuccess: ["Arf arf! You’re in, pup! Time to chase some FEED!","Woof! Wallet’s hooked, ready to roll in Shibarium!","Yip yip! Connected, hooman! Let’s swap some treats!","Bow wow! Welcome aboard, let’s sniff out some swaps!"],
            connectFail: ["Grrr... Wallet slipped away, try again, hooman!","Woof? No wallet scent detected, give it another go!","Arf arf! Something barked up, retry connecting, pup!","Ruff! Wallet’s hiding, let’s dig it out again!"],
            setPercentage: (percent) => [`Woof! ${percent}% in? You’re a bold Shib, hooman!`,`Arf arf! Going ${percent}%? Let’s dig into that swap!`,`Bow wow! ${percent}% of the stash? Pawsitively daring!`,`Yip! ${percent}%? You’re chasing big bones today!`],
            calcStart: ["Woof! Sniffing out the best routes, hang tight!","Arf! Digging up some swap numbers, stay put, pup!","Bow wow! Crunching bones, I’ll fetch the output soon!","Ruff! Calculating your treat, give me a sec, hooman!"],
            calcSuccess: (amount, symbol) => [`Arf! Found ya ${amount} ${symbol}! Ready to swap, pup?`,`Woof woof! Snagged ${amount} ${symbol}, let’s roll!`,`Yip yip! Dug up ${amount} ${symbol}, happy tail wags!`,`Bow wow! ${amount} ${symbol} sniffed out, swap time!`],
            calcFail: ["Grrr... No path for these bones, try a new pair, pup!","Woof? Swap trail’s cold, pick another token, hooman!","Arf arf! Couldn’t fetch the output, let’s retry!","Ruff! Swap math barked up, give it another go!"],
            swapStart: ["Woof woof! Swapping time, let’s fetch those tokens!","Arf! Launching the swap, hold onto your leash, pup!","Bow wow! Trading bones, here we go, Shib style!","Yip! Swapping in Shibarium, let’s make it pawsome!"],
            swapSuccess: ["Arf arf! Swap done, you’re a Woofswap champ, hooman!","Woof! Tokens fetched, tail-wagging success, pup!","Bow wow! Swapped like a pro, time to celebrate!","Yip yip! Swap complete, you’re the top dog now!"],
            swapFail: ["Grrr... Swap didn’t work, let’s try again, pup!","Woof? Swap got lost, retry it, clever hooman!","Arf! Token chase failed, another go, Shib friend?","Ruff ruff! Swap slipped, let’s dig it up again!"],
            swapNoAmount: ["Arf! No amount? How am I supposed to swap air?!","Woof woof! Gimme a number, pup, or we’re stuck!","Bow wow! Empty swap? Fill it up, hooman!","Ruff! Amount’s missing, let’s fetch some digits!"],
            userDenied: ["Woof woof! You scared me off, hooman! Approve next time, pup!","Arf! No swap today? You’re a tricky one, let’s try again!","Bow wow! Rejected my trade? Give me a bone next time!","Ruff ruff! You denied me, hooman! Let’s wag back later!"]
        };

        function getRandomMessage(type, param1, param2) {
            const messages = dogMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('payToken').addEventListener('change', updateBalances);
            setupWalletListeners();
        });

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            const dogMessage = document.getElementById('dogMessage');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask or another wallet.");
                connectButton.disabled = true;
                status.innerText = "Connecting...";
                dogMessage.innerText = getRandomMessage('connectStart');
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                await switchToShibarium();
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                feedBuyAndSell = new web3.eth.Contract(feedBuyAndSellAbi, feedBuyAndSellAddress);
                updateUIAfterConnect();
                await updateBalances();
            } catch (error) {
                status.innerText = "Failed: " + error.message;
                dogMessage.innerText = getRandomMessage('connectFail');
                console.error(error);
                resetUI();
            } finally {
                connectButton.disabled = false;
            }
        }

        async function switchToShibarium() {
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 109) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: "0x6d" }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [shibarium]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
        }

        function updateUIAfterConnect() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            const dogMessage = document.getElementById('dogMessage');
            connectButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
            status.innerText = "Connected to Shibarium";
            dogMessage.innerText = getRandomMessage('connectSuccess');
        }

        function resetUI() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            connectButton.textContent = "Connect Wallet";
            status.innerText = "Click to connect...";
        }

        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await switchToShibarium();
                        router = new web3.eth.Contract(routerAbi, routerAddress);
                        factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                        feedBuyAndSell = new web3.eth.Contract(feedBuyAndSellAbi, feedBuyAndSellAddress);
                        updateUIAfterConnect();
                        await updateBalances();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    feedBuyAndSell = null;
                    resetUI();
                    document.getElementById('dogMessage').innerText = getRandomMessage('connectFail');
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 109) {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    feedBuyAndSell = null;
                    resetUI();
                    document.getElementById('networkStatus').innerText = "Wrong network. Reconnect to Shibarium.";
                    document.getElementById('dogMessage').innerText = "Woof! Wrong chain, pup! Switch to Shibarium!";
                } else if (account) {
                    await connectWallet();
                }
            });
        }

        async function updateBalances() {
            if (!web3 || !account) return;
            const payTokenSymbol = document.getElementById('payToken').value;
            const payToken = tokens[payTokenSymbol];
            if (payToken.isNative) {
                payBalance = await web3.eth.getBalance(account);
                document.getElementById('buyBalance').innerText = `Balance: ${web3.utils.fromWei(payBalance, 'ether')}`;
            } else {
                const tokenContract = new web3.eth.Contract(erc20Abi, payToken.address);
                payBalance = await tokenContract.methods.balanceOf(account).call();
                document.getElementById('buyBalance').innerText = `Balance: ${web3.utils.fromWei(payBalance, 'ether')}`;
            }
            const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
            feedBalance = await feedContract.methods.balanceOf(account).call();
            document.getElementById('sellBalance').innerText = `Balance: ${web3.utils.fromWei(feedBalance, 'ether')}`;
        }

        function setPercentage(percentage) {
            const dogMessage = document.getElementById('dogMessage');
            if (!payBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = web3.utils.fromWei(payBalance, 'ether');
            } else {
                amount = web3.utils.fromWei(payBalance, 'ether') * (percentage / 100);
            }
            if (percentage === 100 && document.getElementById('payToken').value === 'BONE') {
                amount = Math.max(0, amount - 0.01);
            }
            document.getElementById('payAmount').value = amount.toString();
            dogMessage.innerText = getRandomMessage('setPercentage', percentage);
        }

        function setSellPercentage(percentage) {
            const dogMessage = document.getElementById('dogMessage');
            if (!feedBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = web3.utils.fromWei(feedBalance, 'ether');
            } else {
                amount = web3.utils.fromWei(feedBalance, 'ether') * (percentage / 100);
            }
            document.getElementById('sellAmount').value = amount.toString();
            dogMessage.innerText = getRandomMessage('setPercentage', percentage);
        }

        async function buyFEED() {
            const dogMessage = document.getElementById('dogMessage');
            const status = document.getElementById('networkStatus');
            const buyButton = document.getElementById('buyButton');
            const buyNote = document.getElementById('buyNote');
            if (!web3 || !account) {
                status.innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            const payTokenSymbol = document.getElementById('payToken').value;
            const payToken = tokens[payTokenSymbol];
            const amountIn = document.getElementById('payAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            if (!payToken.isNative) {
                const tokenContract = new web3.eth.Contract(erc20Abi, payToken.address);
                const tokenBalance = await tokenContract.methods.balanceOf(account).call();
                if (web3.utils.toBN(tokenBalance).lt(amountInWei)) {
                    status.innerText = "Insufficient token balance.";
                    dogMessage.innerText = "Woof! Not enough bones to swap, pup!";
                    return;
                }
            }
            let possibleRoutes = [];
            if (payTokenSymbol === 'BONE') {
                possibleRoutes = [
                    [{ from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.BONE.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.BONE.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'WOOF') {
                possibleRoutes = [
                    [{ from: tokens.WOOF.address, to: tokens.BONE.address, stable: false }, { from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'LUISA') {
                possibleRoutes = [
                    [{ from: tokens.LUISA.address, to: tokens.BONE.address, stable: false }, { from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            }
            buyNote.innerHTML = `Checking routes... <span class="spinner"></span>`;
            dogMessage.innerText = getRandomMessage('calcStart');
            let routes = [], totalOutput = 0;
            try {
                for (const route of possibleRoutes) {
                    let valid = true;
                    for (let i = 0; i < route.length; i++) {
                        const pair = await factory.methods.getPair(route[i].from, route[i].to, false).call();
                        if (pair === '0x0000000000000000000000000000000000000000') {
                            valid = false;
                            break;
                        }
                    }
                    if (!valid) continue;
                    const amounts = await router.methods.getAmountsOut(amountInWei, route).call();
                    const output = parseFloat(web3.utils.fromWei(amounts[amounts.length - 1], 'ether'));
                    routes.push({ path: route, output });
                    totalOutput += output;
                }
                if (!routes.length) {
                    buyNote.innerHTML = 'No available routes found.';
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                routes.sort((a, b) => b.output - a.output);
                const allocation = routes.map(r => ({ ...r, share: (r.output / totalOutput) * 100 }));
                let html = 'Available Routes:<br>';
                allocation.forEach(r => {
                    const path = r.path.map(p => Object.keys(tokens).find(k => tokens[k].address === p.from) || p.from).join(' -> ') + ' -> FEED';
                    html += `${path}: ${r.output.toFixed(2)} (${r.share.toFixed(1)}%)<br>`;
                });
                html += `Total: ${totalOutput.toFixed(2)} FEED`;
                buyNote.innerHTML = html;
                dogMessage.innerText = getRandomMessage('calcSuccess', totalOutput.toFixed(2), 'FEED');
                const swapRoutes = allocation.map(r => ({
                    amountIn: web3.utils.toWei((amountIn * r.share / 100).toString(), 'ether'),
                    amountOutMin: 0,
                    path: r.path
                }));
                const expectedAmounts = await feedBuyAndSell.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    swapRoutes[i].amountOutMin = expectedAmounts[i];
                }
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                buyButton.disabled = true;
                status.innerText = "Processing buy...";
                dogMessage.innerText = getRandomMessage('swapStart');
                if (payTokenSymbol === 'BONE') {
                    await feedBuyAndSell.methods.buyWithBONE(swapRoutes, deadline).send({ from: account, value: amountInWei });
                } else if (payTokenSymbol === 'WOOF') {
                    await feedBuyAndSell.methods.buyWithWOOF(amountInWei.toString(), swapRoutes, deadline).send({ from: account });
                } else if (payTokenSymbol === 'LUISA') {
                    await feedBuyAndSell.methods.buyWithLUISA(amountInWei.toString(), swapRoutes, deadline).send({ from: account });
                }
                status.innerText = "Buy successful!";
                dogMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('payAmount').value = '';
                await updateBalances();
            } catch (error) {
                console.error("Buy failed:", error);
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("User denied transaction signature")) {
                    errorMessage = "User denied transaction signature.";
                    dogMessage.innerText = getRandomMessage('userDenied');
                } else {
                    dogMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
                buyNote.innerHTML = '';
            } finally {
                buyButton.disabled = false;
            }
        }

        async function sellFEED() {
            const dogMessage = document.getElementById('dogMessage');
            const status = document.getElementById('networkStatus');
            const sellButton = document.getElementById('sellButton');
            const sellNote = document.getElementById('sellNote');
            if (!web3 || !account) {
                status.innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            const amountIn = document.getElementById('sellAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
            const tokenBalance = await feedContract.methods.balanceOf(account).call();
            if (web3.utils.toBN(tokenBalance).lt(amountInWei)) {
                status.innerText = "Insufficient FEED balance.";
                dogMessage.innerText = "Woof! Not enough FEED to sell, pup!";
                return;
            }
            const possibleRoutes = [
                [{ from: tokens.FEED.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.BONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.BONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.BONE.address, stable: false }]
            ];
            sellNote.innerHTML = `Checking routes... <span class="spinner"></span>`;
            dogMessage.innerText = getRandomMessage('calcStart');
            let routes = [], totalOutput = 0;
            try {
                for (const route of possibleRoutes) {
                    let valid = true;
                    for (let i = 0; i < route.length; i++) {
                        const pair = await factory.methods.getPair(route[i].from, route[i].to, false).call();
                        if (pair === '0x0000000000000000000000000000000000000000') {
                            valid = false;
                            break;
                        }
                    }
                    if (!valid) continue;
                    const amounts = await router.methods.getAmountsOut(amountInWei, route).call();
                    const output = parseFloat(web3.utils.fromWei(amounts[amounts.length - 1], 'ether'));
                    routes.push({ path: route, output });
                    totalOutput += output;
                }
                if (!routes.length) {
                    sellNote.innerHTML = 'No available routes found.';
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                routes.sort((a, b) => b.output - a.output);
                const allocation = routes.map(r => ({ ...r, share: (r.output / totalOutput) * 100 }));
                let html = 'Available Routes:<br>';
                allocation.forEach(r => {
                    const path = ['FEED'].concat(r.path.map(p => Object.keys(tokens).find(k => tokens[k].address === p.to) || p.to)).join(' -> ');
                    html += `${path}: ${r.output.toFixed(2)} (${r.share.toFixed(1)}%)<br>`;
                });
                html += `Total: ${totalOutput.toFixed(2)} BONE`;
                sellNote.innerHTML = html;
                dogMessage.innerText = getRandomMessage('calcSuccess', totalOutput.toFixed(2), 'BONE');
                const swapRoutes = allocation.map(r => ({
                    amountIn: web3.utils.toWei((amountIn * r.share / 100).toString(), 'ether'),
                    amountOutMin: 0,
                    path: r.path
                }));
                const expectedAmounts = await feedBuyAndSell.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    swapRoutes[i].amountOutMin = expectedAmounts[i];
                }
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                sellButton.disabled = true;
                status.innerText = "Processing sell...";
                dogMessage.innerText = getRandomMessage('swapStart');
                await feedBuyAndSell.methods.sellToBONE(amountInWei.toString(), swapRoutes, deadline).send({ from: account });
                status.innerText = "Sell successful!";
                dogMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('sellAmount').value = '';
                await updateBalances();
            } catch (error) {
                console.error("Sell failed:", error);
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("User denied transaction signature")) {
                    errorMessage = "User denied transaction signature.";
                    dogMessage.innerText = getRandomMessage('userDenied');
                } else {
                    dogMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
                sellNote.innerHTML = '';
            } finally {
                sellButton.disabled = false;
            }
        }
    </script>
</body>
</html>
