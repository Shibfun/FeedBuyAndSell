<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FEED Swap - Woofswap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #e68a00; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ff9100;
        }
        select, input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: #4a4f7a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
        }
        .percentage-buttons button:hover { background: #5a5f8a; }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:disabled {
            background: #4a4f7a;
            cursor: not-allowed;
        }
        .swap-button:hover:not(:disabled) { background: #e68a00; }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .swap-note {
            font-size: 0.9em;
            color: #ff9100;
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .percentage-buttons button { padding: 5px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">FEED Swap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>Buy FEED with</span>
                <span id="buyBalance">Balance: 0</span>
            </div>
            <select id="payToken">
                <option value="BONE">BONE</option>
                <option value="WOOF">WOOF</option>
                <option value="LUISA">LUISA</option>
            </select>
            <input type="number" id="payAmount" placeholder="0.0" step="0.01">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="buyNote"></div>
        </div>
        <button class="swap-button" id="approveBuyButton" onclick="approveBuyToken()" style="display: none;">Approve Token</button>
        <button class="swap-button" id="buyButton" onclick="buyFEED()">Buy FEED</button>
        <div class="swap-box">
            <div class="balance-row">
                <span>Sell FEED for BONE</span>
                <span id="sellBalance">Balance: 0</span>
            </div>
            <input type="number" id="sellAmount" placeholder="0.0" step="0.01">
            <div class="percentage-buttons">
                <button onclick="setSellPercentage(25)">25%</button>
                <button onclick="setSellPercentage(50)">50%</button>
                <button onclick="setSellPercentage(75)">75%</button>
                <button onclick="setSellPercentage(100)">MAX</button>
            </div>
            <div class="swap-note" id="sellNote"></div>
        </div>
        <button class="swap-button" id="approveButton" onclick="approveFEED()">Approve FEED</button>
        <button class="swap-button" id="sellButton" onclick="sellFEED()" style="display: none;">Sell FEED</button>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        // Token addresses and configurations
        const tokens = {
            BONE: { address: "0x839FdB6cc98342B428E074C1573ADF6D48CA3bFd", symbol: "BONE", isNative: true },
            WOOF: { address: "0xD0daa7B6ff1B40d3cc6F0B2Cf7E85cB993D1c834", symbol: "WOOF" },
            LUISA: { address: "0x0cCD687CC6F8461170336D8e8cf46A39313DEab9", symbol: "LUISA" },
            FEED: { address: "0xe9Cb2D7ADC24Fc59FE00D6C0A0669BDF16805Fe0", symbol: "FEED" }
        };
        const routerAddress = "0x96b16aBD53Bfd765F4CD118590C1d0be8B57DE24";
        const factoryAddress = "0xB9fbdFA27B7ba8BB2d4bB4aB399e4c55F0F7F83a";
        const feedBuyAndSellAddress = "0x852f466F286F3fa32B6f3ca1D65080D1070Dabf4";

        // ABIs for interacting with contracts
        const routerAbi = [
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];
        const factoryAbi = [
            {"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];
        const pairAbi = [
            {"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint256","name":"reserve0","type":"uint256"},{"internalType":"uint256","name":"reserve1","type":"uint256"},{"internalType":"uint32","name":"blockTimestampLast","type":"uint32"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];
        const feedBuyAndSellAbi = [
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithWOOF","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"buyWithLUISA","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"}],"name":"getExpectedAmountsOut","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"totalAmountIn","type":"uint256"},{"components":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct IRouter.route[]","name":"path","type":"tuple[]"}],"internalType":"struct FeedBuyAndSell.SwapRoute[]","name":"routes","type":"tuple[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"sellToBONE","outputs":[{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"}
        ];
        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"}
        ];
        const shibarium = {
            chainId: 109,
            chainName: 'Shibarium',
            nativeCurrency: { name: 'BONE', symbol: 'BONE', decimals: 18 },
            rpcUrls: ['https://rpc.shibrpc.com'],
            blockExplorerUrls: ['https://shibariumscan.io']
        };

        // Global variables
        let web3, account, router, factory, feedBuyAndSell;
        let payBalance = '0';
        let feedBalance = '0';
        let pairCache = new Map(); // Cache for pair addresses
        let reserveCache = new Map(); // Cache for reserves

        // Event listeners for DOM loading
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('payToken').addEventListener('change', updateBalances);
            document.getElementById('payAmount').addEventListener('input', checkBuyRoutes);
            document.getElementById('sellAmount').addEventListener('input', checkSellRoutes);
            setupWalletListeners();
        });

        // Connect to wallet and initialize contracts
        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask or another wallet.");
                connectButton.disabled = true;
                status.innerHTML = "Connecting... <span class='spinner'></span>";
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                await switchToShibarium();
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                feedBuyAndSell = new web3.eth.Contract(feedBuyAndSellAbi, feedBuyAndSellAddress);
                connectButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                status.innerText = "Connected to Shibarium";
                await updateBalances();
            } catch (error) {
                status.innerText = `Failed: ${error.message}`;
                console.error(error);
                resetUI();
            } finally {
                connectButton.disabled = false;
            }
        }

        // Switch to Shibarium network
        async function switchToShibarium() {
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 109) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: "0x6d" }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [shibarium]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
        }

        // Reset UI when disconnected
        function resetUI() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            connectButton.textContent = "Connect Wallet";
            status.innerText = "Click to connect...";
            document.getElementById('buyBalance').innerText = "Balance: 0";
            document.getElementById('sellBalance').innerText = "Balance: 0";
            document.getElementById('buyNote').innerHTML = "";
            document.getElementById('sellNote').innerHTML = "";
            document.getElementById('buyButton').disabled = true;
            document.getElementById('approveButton').disabled = true;
        }

        // Setup wallet event listeners for account and chain changes
        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await switchToShibarium();
                        router = new web3.eth.Contract(routerAbi, routerAddress);
                        factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                        feedBuyAndSell = new web3.eth.Contract(feedBuyAndSellAbi, feedBuyAndSellAddress);
                        document.getElementById('connectWalletButton').textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
                        document.getElementById('networkStatus').innerText = "Connected to Shibarium";
                        await updateBalances();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    feedBuyAndSell = null;
                    resetUI();
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 109) {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    feedBuyAndSell = null;
                    resetUI();
                    document.getElementById('networkStatus').innerText = "Wrong network. Reconnect to Shibarium.";
                } else if (account) {
                    await connectWallet();
                }
            });
        }

        // Update balances for the selected pay token and FEED
        async function updateBalances() {
            if (!web3 || !account) return;
            const payTokenSymbol = document.getElementById('payToken').value;
            const payToken = tokens[payTokenSymbol];
            try {
                if (payToken.isNative) {
                    payBalance = await web3.eth.getBalance(account);
                    document.getElementById('buyBalance').innerText = `Balance: ${parseFloat(web3.utils.fromWei(payBalance, 'ether')).toFixed(4)}`;
                } else {
                    const tokenContract = new web3.eth.Contract(erc20Abi, payToken.address);
                    payBalance = await tokenContract.methods.balanceOf(account).call();
                    document.getElementById('buyBalance').innerText = `Balance: ${parseFloat(web3.utils.fromWei(payBalance, 'ether')).toFixed(4)}`;
                }
                const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
                feedBalance = await feedContract.methods.balanceOf(account).call();
                document.getElementById('sellBalance').innerText = `Balance: ${parseFloat(web3.utils.fromWei(feedBalance, 'ether')).toFixed(4)}`;
            } catch (error) {
                console.error("Error updating balances:", error);
                document.getElementById('networkStatus').innerText = "Error fetching balances.";
            }
        }

        // Set percentage of balance for buying (reserves 0.001 BONE for MAX)
        function setPercentage(percentage) {
            if (!payBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = parseFloat(web3.utils.fromWei(payBalance, 'ether'));
                if (document.getElementById('payToken').value === 'BONE') {
                    amount = Math.max(0, amount - 0.001); // Reserve 0.001 BONE for MAX
                }
            } else {
                amount = parseFloat(web3.utils.fromWei(payBalance, 'ether')) * (percentage / 100);
            }
            document.getElementById('payAmount').value = amount.toFixed(4);
            checkBuyRoutes();
        }

        // Set percentage of balance for selling (no reserve for FEED)
        function setSellPercentage(percentage) {
            if (!feedBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = parseFloat(web3.utils.fromWei(feedBalance, 'ether'));
            } else {
                amount = parseFloat(web3.utils.fromWei(feedBalance, 'ether')) * (percentage / 100);
            }
            document.getElementById('sellAmount').value = amount.toFixed(4);
            checkSellRoutes();
        }

        // Fetch pair address with caching
        async function getPairAddress(tokenA, tokenB) {
            const key = `${tokenA}-${tokenB}-false`;
            if (pairCache.has(key)) {
                return pairCache.get(key);
            }
            const pairAddress = await factory.methods.getPair(tokenA, tokenB, false).call();
            pairCache.set(key, pairAddress);
            return pairAddress;
        }

        // Fetch reserves for a pool with caching
        async function getPoolReserves(tokenA, tokenB) {
            const pairAddress = await getPairAddress(tokenA, tokenB);
            if (pairAddress === '0x0000000000000000000000000000000000000000') {
                return { reserveA: web3.utils.toBN('0'), reserveB: web3.utils.toBN('0'), exists: false };
            }
            const key = pairAddress;
            if (reserveCache.has(key)) {
                const cached = reserveCache.get(key);
                return { reserveA: web3.utils.toBN(cached.reserveA), reserveB: web3.utils.toBN(cached.reserveB), exists: true };
            }
            const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
            const reserves = await pairContract.methods.getReserves().call();
            const token0 = await pairContract.methods.token0().call();
            const reserveA = token0 === tokenA ? reserves.reserve0 : reserves.reserve1;
            const reserveB = token0 === tokenA ? reserves.reserve1 : reserves.reserve0;
            reserveCache.set(key, { reserveA, reserveB });
            return { reserveA: web3.utils.toBN(reserveA), reserveB: web3.utils.toBN(reserveB), exists: true };
        }

        // Fetch FEED reserves for BONE/FEED, WOOF/FEED, and LUISA/FEED pools
        async function getFeedReserves() {
            const feedReserves = {};
            const boneFeed = await getPoolReserves(tokens.BONE.address, tokens.FEED.address);
            feedReserves['BONE/FEED'] = boneFeed.exists ? (boneFeed.reserveB.toString() === tokens.FEED.address ? boneFeed.reserveA : boneFeed.reserveB) : web3.utils.toBN('0');
            const woofFeed = await getPoolReserves(tokens.WOOF.address, tokens.FEED.address);
            feedReserves['WOOF/FEED'] = woofFeed.exists ? (woofFeed.reserveB.toString() === tokens.FEED.address ? woofFeed.reserveA : woofFeed.reserveB) : web3.utils.toBN('0');
            const luisaFeed = await getPoolReserves(tokens.LUISA.address, tokens.FEED.address);
            feedReserves['LUISA/FEED'] = luisaFeed.exists ? (luisaFeed.reserveB.toString() === tokens.FEED.address ? luisaFeed.reserveA : luisaFeed.reserveB) : web3.utils.toBN('0');
            return feedReserves;
        }

        // Calculate output for a given route with the specified amountIn
        async function getOutputForRoute(route, amountIn) {
            let currentAmount = web3.utils.toBN(amountIn);
            for (let i = 0; i < route.length; i++) {
                const { reserveA, reserveB, exists } = await getPoolReserves(route[i].from, route[i].to);
                if (!exists) return web3.utils.toBN('0');
                const reserveIn = route[i].from === route[0].from ? reserveA : reserveB;
                const reserveOut = route[i].from === route[0].from ? reserveB : reserveA;
                if (currentAmount.gt(reserveIn)) {
                    currentAmount = reserveIn;
                }
                if (currentAmount.lte(web3.utils.toBN('0'))) {
                    return web3.utils.toBN('0');
                }
                const amounts = await router.methods.getAmountsOut(currentAmount.toString(), route.slice(0, i + 1)).call();
                currentAmount = web3.utils.toBN(amounts[amounts.length - 1]);
                if (currentAmount.gt(reserveOut)) {
                    currentAmount = reserveOut;
                }
            }
            return currentAmount;
        }

        // Check allowance for a token
        async function checkAllowance(tokenAddress, amount) {
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, feedBuyAndSellAddress).call();
            return web3.utils.toBN(allowance).gte(web3.utils.toBN(amount));
        }

        // Check buy routes and optimize allocation based on FEED reserves
        async function checkBuyRoutes() {
            const buyNote = document.getElementById('buyNote');
            const buyButton = document.getElementById('buyButton');
            const approveBuyButton = document.getElementById('approveBuyButton');
            const payTokenSymbol = document.getElementById('payToken').value;
            const payToken = tokens[payTokenSymbol];
            const amountIn = document.getElementById('payAmount').value;
            if (!web3 || !account || !amountIn || amountIn <= 0) {
                buyNote.innerHTML = '';
                buyButton.disabled = true;
                approveBuyButton.style.display = 'none';
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toWei(amountIn.toString(), 'ether');
            } catch (error) {
                buyNote.innerHTML = 'Invalid amount entered.';
                buyButton.disabled = true;
                approveBuyButton.style.display = 'none';
                return;
            }
            if (web3.utils.toBN(amountInWei).gt(web3.utils.toBN(payBalance))) {
                buyNote.innerHTML = 'Insufficient balance.';
                buyButton.disabled = true;
                approveBuyButton.style.display = 'none';
                return;
            }
            buyNote.innerHTML = `Checking routes... <span class="spinner"></span>`;

            // Check allowance for non-native tokens
            let needsApproval = false;
            if (!payToken.isNative) {
                const hasAllowance = await checkAllowance(payToken.address, amountInWei);
                needsApproval = !hasAllowance;
            }

            // Define possible routes based on pay token
            let possibleRoutes = [];
            if (payTokenSymbol === 'BONE') {
                possibleRoutes = [
                    [{ from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.BONE.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.BONE.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'WOOF') {
                possibleRoutes = [
                    [{ from: tokens.WOOF.address, to: tokens.BONE.address, stable: false }, { from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.WOOF.address, to: tokens.FEED.address, stable: false }]
                ];
            } else if (payTokenSymbol === 'LUISA') {
                possibleRoutes = [
                    [{ from: tokens.LUISA.address, to: tokens.BONE.address, stable: false }, { from: tokens.BONE.address, to: tokens.FEED.address, stable: false }],
                    [{ from: tokens.LUISA.address, to: tokens.FEED.address, stable: false }]
                ];
            }

            try {
                const feedReserves = await getFeedReserves();
                const routeWeights = [];
                for (const route of possibleRoutes) {
                    let weight = web3.utils.toBN('0');
                    if (payTokenSymbol === 'BONE') {
                        if (route.length === 1) {
                            weight = feedReserves['BONE/FEED'];
                        } else if (route[1].from === tokens.WOOF.address) {
                            weight = feedReserves['WOOF/FEED'];
                        } else {
                            weight = feedReserves['LUISA/FEED'];
                        }
                    } else if (payTokenSymbol === 'WOOF') {
                        if (route.length === 1) {
                            weight = feedReserves['WOOF/FEED'];
                        } else {
                            weight = feedReserves['BONE/FEED'];
                        }
                    } else if (payTokenSymbol === 'LUISA') {
                        if (route.length === 1) {
                            weight = feedReserves['LUISA/FEED'];
                        } else {
                            weight = feedReserves['BONE/FEED'];
                        }
                    }
                    if (weight.gt(web3.utils.toBN('0'))) {
                        routeWeights.push({ route, weight });
                    }
                }

                if (!routeWeights.length) {
                    buyNote.innerHTML = 'No available routes found.';
                    buyButton.disabled = true;
                    approveBuyButton.style.display = 'none';
                    return;
                }

                let totalWeight = web3.utils.toBN('0');
                for (const { weight } of routeWeights) {
                    totalWeight = totalWeight.add(weight);
                }

                const swapRoutes = [];
                let totalOutput = web3.utils.toBN('0');
                let remainingAmount = web3.utils.toBN(amountInWei);
                let html = 'AVAILABLE ROUTES:<br>';

                for (const { route, weight } of routeWeights) {
                    const share = weight.mul(web3.utils.toBN(10000)).div(totalWeight).toNumber() / 10000;
                    const routeAmountIn = web3.utils.toBN(amountInWei).mul(web3.utils.toBN(Math.floor(share * 10000))).div(web3.utils.toBN(10000));
                    if (routeAmountIn.lte(web3.utils.toBN('0'))) continue;
                    if (routeAmountIn.gt(remainingAmount)) continue;
                    remainingAmount = remainingAmount.sub(routeAmountIn);
                    const output = await getOutputForRoute(route, routeAmountIn);
                    const outputEther = parseFloat(web3.utils.fromWei(output, 'ether'));
                    totalOutput = totalOutput.add(output);
                    const path = route.map(p => Object.keys(tokens).find(k => tokens[k].address === p.from) || p.from).join(' -> ') + ' -> FEED';
                    html += `${path}: ${outputEther.toFixed(2)} (${(share * 100).toFixed(1)}%)<br>`;
                    swapRoutes.push({
                        amountIn: routeAmountIn.toString(),
                        amountOutMin: 0,
                        path: route,
                        output: outputEther,
                        share: share * 100
                    });
                }

                if (remainingAmount.gt(web3.utils.toBN('0')) && swapRoutes.length > 0) {
                    const bestRoute = routeWeights.reduce((best, current) => current.weight.gt(best.weight) ? current : best);
                    const output = await getOutputForRoute(bestRoute.route, remainingAmount);
                    const outputEther = parseFloat(web3.utils.fromWei(output, 'ether'));
                    totalOutput = totalOutput.add(output);
                    const path = bestRoute.route.map(p => Object.keys(tokens).find(k => tokens[k].address === p.from) || p.from).join(' -> ') + ' -> FEED';
                    const share = outputEther / parseFloat(web3.utils.fromWei(totalOutput, 'ether')) * 100;
                    html += `${path}: ${outputEther.toFixed(2)} (${share.toFixed(1)}%)<br>`;
                    swapRoutes.push({
                        amountIn: remainingAmount.toString(),
                        amountOutMin: 0,
                        path: bestRoute.route,
                        output: outputEther,
                        share
                    });
                }

                if (!swapRoutes.length) {
                    buyNote.innerHTML = 'No available routes found.';
                    buyButton.disabled = true;
                    approveBuyButton.style.display = 'none';
                    return;
                }

                const expectedAmounts = await feedBuyAndSell.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    swapRoutes[i].amountOutMin = expectedAmounts[i];
                }

                const totalOutputEther = parseFloat(web3.utils.fromWei(totalOutput, 'ether'));
                html += `TOTAL: ${totalOutputEther.toFixed(2)} FEED`;
                buyNote.innerHTML = html;
                window.buyRoutes = swapRoutes;
                window.buyTotalAmount = amountInWei;
                window.buyPayToken = payTokenSymbol;
                buyButton.disabled = false;
                approveBuyButton.style.display = needsApproval ? 'block' : 'none';
                buyButton.style.display = needsApproval ? 'none' : 'block';
            } catch (error) {
                console.error("Error checking buy routes:", error);
                buyNote.innerHTML = 'Error checking routes: ' + (error.message || "Unknown error");
                buyButton.disabled = true;
                approveBuyButton.style.display = 'none';
            }
        }

        // Approve token for buying
        async function approveBuyToken() {
            const approveBuyButton = document.getElementById('approveBuyButton');
            const buyButton = document.getElementById('buyButton');
            const status = document.getElementById('networkStatus');
            const payTokenSymbol = window.buyPayToken;
            const totalAmount = window.buyTotalAmount;
            if (!web3 || !account || !totalAmount) {
                status.innerText = "Please connect wallet and enter a valid amount.";
                return;
            }
            try {
                approveBuyButton.disabled = true;
                status.innerHTML = `Approving ${payTokenSymbol}... <span class="spinner"></span>`;
                const tokenContract = new web3.eth.Contract(erc20Abi, tokens[payTokenSymbol].address);
                await tokenContract.methods.approve(feedBuyAndSellAddress, totalAmount).send({ from: account });
                status.innerText = "Approval successful!";
                approveBuyButton.style.display = 'none';
                buyButton.style.display = 'block';
            } catch (error) {
                console.error("Approval failed:", error);
                status.innerText = error.message || "Approval failed.";
            } finally {
                approveBuyButton.disabled = false;
            }
        }

        // Execute buy transaction
        async function buyFEED() {
            const buyButton = document.getElementById('buyButton');
            const status = document.getElementById('networkStatus');
            const buyNote = document.getElementById('buyNote');
            if (!web3 || !account || !window.buyRoutes) {
                status.innerText = "Please connect wallet and enter a valid amount.";
                return;
            }
            const payTokenSymbol = window.buyPayToken;
            const totalAmount = window.buyTotalAmount;
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            try {
                buyButton.disabled = true;
                status.innerHTML = "Processing buy... <span class='spinner'></span>";
                if (payTokenSymbol === 'BONE') {
                    await feedBuyAndSell.methods.buyWithBONE(window.buyRoutes, deadline).send({ from: account, value: totalAmount });
                } else if (payTokenSymbol === 'WOOF') {
                    await feedBuyAndSell.methods.buyWithWOOF(totalAmount, window.buyRoutes, deadline).send({ from: account });
                } else if (payTokenSymbol === 'LUISA') {
                    await feedBuyAndSell.methods.buyWithLUISA(totalAmount, window.buyRoutes, deadline).send({ from: account });
                }
                status.innerText = "Buy successful!";
                document.getElementById('payAmount').value = '';
                buyNote.innerHTML = '';
                await updateBalances();
            } catch (error) {
                console.error("Buy failed:", error);
                status.innerText = error.message || "Buy failed.";
            } finally {
                buyButton.disabled = false;
            }
        }

        // Check sell routes and optimize allocation based on FEED reserves
        async function checkSellRoutes() {
            const sellNote = document.getElementById('sellNote');
            const approveButton = document.getElementById('approveButton');
            const sellButton = document.getElementById('sellButton');
            const amountIn = document.getElementById('sellAmount').value;
            if (!web3 || !account || !amountIn || amountIn <= 0) {
                sellNote.innerHTML = '';
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                approveButton.disabled = true;
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toWei(amountIn.toString(), 'ether');
            } catch (error) {
                sellNote.innerHTML = 'Invalid amount entered.';
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                approveButton.disabled = true;
                return;
            }
            if (web3.utils.toBN(amountInWei).gt(web3.utils.toBN(feedBalance))) {
                sellNote.innerHTML = 'Insufficient balance.';
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                approveButton.disabled = true;
                return;
            }
            sellNote.innerHTML = `Checking routes... <span class="spinner"></span>`;

            // Check allowance for FEED
            const hasAllowance = await checkAllowance(tokens.FEED.address, amountInWei);
            const needsApproval = !hasAllowance;

            const possibleRoutes = [
                [{ from: tokens.FEED.address, to: tokens.LUISA.address, stable: false }, { from: tokens.LUISA.address, to: tokens.BONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.WOOF.address, stable: false }, { from: tokens.WOOF.address, to: tokens.BONE.address, stable: false }],
                [{ from: tokens.FEED.address, to: tokens.BONE.address, stable: false }]
            ];

            try {
                const feedReserves = await getFeedReserves();
                const routeWeights = [];
                for (const route of possibleRoutes) {
                    let weight = web3.utils.toBN('0');
                    if (route.length === 1) {
                        weight = feedReserves['BONE/FEED'];
                    } else if (route[0].to === tokens.WOOF.address) {
                        weight = feedReserves['WOOF/FEED'];
                    } else {
                        weight = feedReserves['LUISA/FEED'];
                    }
                    if (weight.gt(web3.utils.toBN('0'))) {
                        routeWeights.push({ route, weight });
                    }
                }

                if (!routeWeights.length) {
                    sellNote.innerHTML = 'No available routes found.';
                    approveButton.style.display = 'block';
                    sellButton.style.display = 'none';
                    approveButton.disabled = true;
                    return;
                }

                let totalWeight = web3.utils.toBN('0');
                for (const { weight } of routeWeights) {
                    totalWeight = totalWeight.add(weight);
                }

                const swapRoutes = [];
                let totalOutput = web3.utils.toBN('0');
                let remainingAmount = web3.utils.toBN(amountInWei);
                let html = 'AVAILABLE ROUTES:<br>';

                for (const { route, weight } of routeWeights) {
                    const share = weight.mul(web3.utils.toBN(10000)).div(totalWeight).toNumber() / 10000;
                    const routeAmountIn = web3.utils.toBN(amountInWei).mul(web3.utils.toBN(Math.floor(share * 10000))).div(web3.utils.toBN(10000));
                    if (routeAmountIn.lte(web3.utils.toBN('0'))) continue;
                    if (routeAmountIn.gt(remainingAmount)) continue;
                    remainingAmount = remainingAmount.sub(routeAmountIn);
                    const output = await getOutputForRoute(route, routeAmountIn);
                    const outputEther = parseFloat(web3.utils.fromWei(output, 'ether'));
                    totalOutput = totalOutput.add(output);
                    const path = ['FEED'].concat(route.map(p => Object.keys(tokens).find(k => tokens[k].address === p.to) || p.to)).join(' -> ');
                    html += `${path}: ${outputEther.toFixed(2)} (${(share * 100).toFixed(1)}%)<br>`;
                    swapRoutes.push({
                        amountIn: routeAmountIn.toString(),
                        amountOutMin: 0,
                        path: route,
                        output: outputEther,
                        share: share * 100
                    });
                }

                if (remainingAmount.gt(web3.utils.toBN('0')) && swapRoutes.length > 0) {
                    const bestRoute = routeWeights.reduce((best, current) => current.weight.gt(best.weight) ? current : best);
                    const output = await getOutputForRoute(bestRoute.route, remainingAmount);
                    const outputEther = parseFloat(web3.utils.fromWei(output, 'ether'));
                    totalOutput = totalOutput.add(output);
                    const path = ['FEED'].concat(bestRoute.route.map(p => Object.keys(tokens).find(k => tokens[k].address === p.to) || p.to)).join(' -> ');
                    const share = outputEther / parseFloat(web3.utils.fromWei(totalOutput, 'ether')) * 100;
                    html += `${path}: ${outputEther.toFixed(2)} (${share.toFixed(1)}%)<br>`;
                    swapRoutes.push({
                        amountIn: remainingAmount.toString(),
                        amountOutMin: 0,
                        path: bestRoute.route,
                        output: outputEther,
                        share
                    });
                }

                if (!swapRoutes.length) {
                    sellNote.innerHTML = 'No available routes found.';
                    approveButton.style.display = 'block';
                    sellButton.style.display = 'none';
                    approveButton.disabled = true;
                    return;
                }

                const expectedAmounts = await feedBuyAndSell.methods.getExpectedAmountsOut(swapRoutes).call();
                for (let i = 0; i < swapRoutes.length; i++) {
                    swapRoutes[i].amountOutMin = expectedAmounts[i];
                }

                const totalOutputEther = parseFloat(web3.utils.fromWei(totalOutput, 'ether'));
                html += `TOTAL: ${totalOutputEther.toFixed(2)} BONE`;
                sellNote.innerHTML = html;
                window.sellRoutes = swapRoutes;
                window.sellTotalAmount = amountInWei;
                approveButton.style.display = needsApproval ? 'block' : 'none';
                sellButton.style.display = needsApproval ? 'none' : 'block';
                approveButton.disabled = false;
            } catch (error) {
                console.error("Error checking sell routes:", error);
                sellNote.innerHTML = 'Error checking routes: ' + (error.message || "Unknown error");
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                approveButton.disabled = true;
            }
        }

        // Approve FEED for selling
        async function approveFEED() {
            const approveButton = document.getElementById('approveButton');
            const sellButton = document.getElementById('sellButton');
            const status = document.getElementById('networkStatus');
            if (!web3 || !account || !window.sellTotalAmount) {
                status.innerText = "Please connect wallet and enter a valid amount.";
                return;
            }
            try {
                approveButton.disabled = true;
                status.innerHTML = "Approving FEED... <span class='spinner'></span>";
                const feedContract = new web3.eth.Contract(erc20Abi, tokens.FEED.address);
                await feedContract.methods.approve(feedBuyAndSellAddress, window.sellTotalAmount).send({ from: account });
                status.innerText = "Approval successful!";
                approveButton.style.display = 'none';
                sellButton.style.display = 'block';
            } catch (error) {
                console.error("Approval failed:", error);
                status.innerText = error.message || "Approval failed.";
            } finally {
                approveButton.disabled = false;
            }
        }

        // Execute sell transaction
        async function sellFEED() {
            const sellButton = document.getElementById('sellButton');
            const approveButton = document.getElementById('approveButton');
            const status = document.getElementById('networkStatus');
            const sellNote = document.getElementById('sellNote');
            if (!web3 || !account || !window.sellRoutes) {
                status.innerText = "Please connect wallet and enter a valid amount.";
                return;
            }
            const totalAmount = window.sellTotalAmount;
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            try {
                sellButton.disabled = true;
                status.innerHTML = "Processing sell... <span class='spinner'></span>";
                await feedBuyAndSell.methods.sellToBONE(totalAmount, window.sellRoutes, deadline).send({ from: account });
                status.innerText = "Sell successful!";
                document.getElementById('sellAmount').value = '';
                sellNote.innerHTML = '';
                approveButton.style.display = 'block';
                sellButton.style.display = 'none';
                await updateBalances();
            } catch (error) {
                console.error("Sell failed:", error);
                status.innerText = error.message || "Sell failed.";
            } finally {
                sellButton.disabled = false;
            }
        }
    </script>
</body>
</html>
